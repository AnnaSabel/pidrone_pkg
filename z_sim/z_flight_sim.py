import numpy as np
import time
from pid_class import PID

class DroneSim():
    
    def __init__(self):
        self.mass = 440.            # mass in grams
        self.motor_latency = 0.005  # motor response latency on skyline 
        self.measure_latency = 0.01 # patcket return response latency
        self.g = -9.81              # acceleration due to gravity
        self.drag_coeff = 0.05
        
        self.pos = 0.           # curr position of the drone
        self.vel = 0.           # curr velocity of the drone
        self.accel = 0.         # curr acceleration of the drone
        self.thrust = 0.        # curr thrust being generated by motors
        self.throttle = 0.      # curr throttle commanded by PID

        self._start_time = time.time()                  # time that the sim was init
        self._prev_step_time = 0                        # previous time that the sim stepped
        self._prev_measure_time = 0                     # previous time a measurement was requested
        self._prev_throttle_time = 0                    # previous time a throttle was commanded
        self.t   = time.time() - self._start_time       # the current time of the sim

    # step the simulation
    def step(self):
        self.t = time.time() - self._start_time
        dt = self.t - self._prev_step_time
        self._prev_step_time = self.t

        self.physics_update(dt)

        # update the thrust being generated after latency
        if self.t - self._prev_throttle_time > self.motor_latency and self.throttle > 0:
            self.thrust = self.pwm_to_thrust(self.throttle)

    # updates the position of the drone based on time elapsed and command throttle
    def physics_update(self, dt):
        drag = np.sign(self.vel) * self.vel ** 2 * self.drag_coeff
        self.accel = self.g + (self.thrust - drag)/self.mass
        self.vel += self.accel * dt
        self.pos += self.vel * dt

        if self.pos < 0:
            self.pos = 0
            self.vel = 0

    # return's a measurement at t
    def measure_pos(self):
        if self.t - self._prev_measure_time > self.measure_latency:
            self._prev_measure_time = self.t
            noise = (np.random.rand(1)[0] - 0.5)/200. * (self.pos+1.0)
            return self.pos + noise
        else: 
            return None

    # calculates the thrust being generated by the motors for a given pwm
    def pwm_to_thrust(self, pwm):
        max_thrust = 10000. # max thrust in newtons
        pwm_min = 1100.
        pwm_max = 1900.
        pwm = max(pwm_min, min(pwm, pwm_max))   # bound the pwm between 1100 and 1900
        throttle_fraction = (pwm - pwm_min) / (pwm_max - pwm_min)   # rescale between 0 and 1
        return throttle_fraction * max_thrust

    def set_throttle(self, pwm):
        self._prev_throttle_time = self.t
        self.throttle = pwm
