#!/usr/bin/python
import rospy
from pidrone_pkg.msg import axes_err, Mode, RC
from geometry_msgs.msg import PoseStamped
import signal
import sys
import traceback
from aarons_pid import PositionPID



class Position(object):
    ''' Struct to store x,y,z'''
    # This should be turned into a data class with the next python 3 release
    def __init__(self, x=0, y=0 ,z=0):
        self.x = x
        self.y = y
        self.z = z
    def __str__(self):
        return "x: %f, y: %f, z: %f" % (self.x, self.y, self.z)

    def __mul__(self, other):
        return Position(self.x * other, self.y * other, self.z * other)

    def __rmul__(self,other):
        return self.__mul__(other)

    def __add__(self,other):
        return Position(self.x + other.x, self.y + other.y, self.z + other.z)

    def __radd__(self,other):
        return self.__add__(other)


def current_mode_callback(msg):
    ''' Updates the current mode for the position pid_controller '''
    global current_mode
    current_mode = msg.mode

def desired_mode_callback(msg):
    ''' Updates the desired mode for the state machine.

        This desired mode will be transitioned to by the state machine if it
        is a valid transition
    '''
    global desired_mode
    desired_mode = msg.mode


def desired_position_callback(msg):
    ''' Updates the desired position '''
    global desired_position
    desired_position.x = msg.pose.position.x
    desired_position.y = msg.pose.position.y
    desired_position.z = msg.pose.position.z


def current_position_callback_vrpn(msg):
    ''' Updates the drone's current position based on the Motion Tracker '''
    global current_position
    # y and z axes are switched in mocap, and positive x is flipped
    current_position.x = - msg.pose.position.x
    current_position.y = msg.pose.position.z
    current_position.z = msg.pose.position.y


def ctrl_c_handler(signal, frame):
    ''' Catches a ctrl-c, and sets the keep_going flag to false'''
    print('Caught ctrl-c! About to Disarm!')
    global keep_going
    keep_going = False


def calc_error(current_position, desired_position):
    ''' Returns desired_position - current_position

    current_position and desired_position are both Position() objects
    that have .x, .y, and .z fields
    '''
    dx = desired_position.x - current_position.x
    dy = desired_position.y - current_position.y
    dz = desired_position.z - current_position.z
    error = Position(dx, dy, dz)
    return error



class PositionController(object):
    ''' Runs a low-pass pre-filter on desired position, then passes off
        control to the position controller based on error between current
        position and filtered-desired-position
    '''

    def __init__(self):
        self.current_filtered_cmd = Position()
        self.current_cmd = Position()
        self.filtered_cmd_pub = rospy.Publisher('/pidrone/intended_position_filtered', PoseStamped, queue_size=1)
        self.position_pid = PositionPID()


    def step(self, next_desired_position, current_position):
        ''' Filters next_desired_position, then passes off to PositionPID.
            Returns the commands generated by the position pid
        '''

        # The intended position, after filtering
        cmd_pos_filt = self.prefilter_position(next_desired_position)

        cmd_pos_filt_msg = PoseStamped()
        cmd_pos_filt_msg.pose.position.x = cmd_pos_filt.x
        cmd_pos_filt_msg.pose.position.y = cmd_pos_filt.y
        cmd_pos_filt_msg.pose.position.z = cmd_pos_filt.z
        cmd_pos_filt_msg.header.stamp = rospy.Time.now()

        self.filtered_cmd_pub.publish(cmd_pos_filt_msg)

        error = calc_error(current_position, cmd_pos_filt)
        cmds = self.position_pid.step(error)
        return cmds


    def prefilter_position(self, next_desired_position):
        ''' Runs a low-pass filter on the desired position '''

        cur_filt_cmd = self.current_filtered_cmd # Filtered position from the previous step
        cur_cmd = self.current_cmd

        c_cur_filt = .999
        c_cmd = .00349

        #c_cur_filt = .999
        #c_cmd = .005

        next_filt = c_cur_filt*cur_filt_cmd + c_cmd*(next_desired_position + cur_cmd)
        self.current_filtered_cmd = next_filt

        return next_filt

    def reset(self):
        ''' Set current_filtered_cmd to be current position, and reset Position PID'''
        global current_position
        self.current_filtered_cmd = current_position
        self.position_pid.reset()


if __name__ == '__main__':

    rospy.init_node('aarons_position_controller')

    global last_heartbeat
    last_heartbeat = rospy.Time.now()

    global desired_mode
    global desired_position
    desired_position = Position()

    global current_position
    current_position = Position()
    global keep_going
    keep_going = True

    def publish_ctrl(ctrl, pub):
        """Publish the controls to /pidrone/controller"""
        msg = RC()
        msg.roll = ctrl[0]
        msg.pitch = ctrl[1]
        msg.yaw = ctrl[2]
        msg.throttle = ctrl[3]
        pub.publish(msg)

    # Verbosity between 0 and 3, 3 is most verbose
    verbose = 2

    position_controller = PositionController()

    current_mode = 'DISARMED'
    desired_mode = 'DISARMED'


    # ROS Setup
    ###########

    # Subscribers
    #############
    rospy.Subscriber('vrpn_client_node/aarondrone/pose', PoseStamped, current_position_callback_vrpn)
    rospy.Subscriber('/pidrone/desired_position', PoseStamped, desired_position_callback)
    rospy.Subscriber('/pidrone/desired_mode', Mode, desired_mode_callback)
    rospy.Subscriber('/pidrone/mode', Mode, current_mode_callback)

    # Publishers
    ############
    error_publisher = rospy.Publisher('/pidrone/err', axes_err, queue_size=1)
    intended_position_publisher = rospy.Publisher('/pidrone/intended_position', PoseStamped, queue_size=1)
    ctrlpub = rospy.Publisher('/pidrone/controller', RC, queue_size=1)

    # Non-ROS Setup
    ###############
    signal.signal(signal.SIGINT, ctrl_c_handler)

    loop_rate = rospy.Rate(100)
    print_counter = 0
    print 'Controlling Position'
    while keep_going:
        # Steps the PID. If we are not flying, this can be used to
        # examine the behavior of the PID based on published values
        fly_commands = position_controller.step(desired_position, current_position)

        if current_mode == 'ARMED':
            if desired_mode == 'FLYING':
                pos_index = 0
                position_controller.reset()
                if verbose >= 3:
                    print('ARMED -> FLYING')
        elif current_mode == 'FLYING':
            if desired_mode == 'FLYING':
                print 'desired position:', desired_position
                print 'current position:', current_position
                # Send command to flight controller based on PID output
                # at current timestep

                # Error is a 'position' struct that has .x, .y, and .z fields
                # giving x, y, and z errors
                r,p,y,t = fly_commands
                print('Fly Commands (r,p,y,t): %d, %d, %d, %d' % (r,p,y,t) )
                print 'midpoint commands:    : 1500, 1480, 1500, 1380'
                publish_ctrl([r,p,y,t], ctrlpub)
                if verbose > 3:
                    print('FLYING -> FLYING')


        intended_pose = PoseStamped()
        intended_pose.pose.position.y = desired_position.y
        intended_pose.header.stamp = rospy.Time.now()
        intended_position_publisher.publish(intended_pose)

        loop_rate.sleep()
        # TODO CTRL C DOESN'T DISARM
