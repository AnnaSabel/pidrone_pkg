#!/usr/bin/python
import rospy
from pidrone_pkg.msg import axes_err, Mode, State
from geometry_msgs.msg import PoseStamped
from std_msgs.msg import String, Float32
from h2rMultiWii import MultiWii
import signal
import numpy as np
import sys
import traceback



class Position(object):
    ''' Struct to store x,y,z'''
    # This should be turned into a data class with the next python 3 release
    def __init__(self, x=0, y=0 ,z=0):
        self.x = x
        self.y = y
        self.z = z
    def __str__(self):
        return "x: %f, y: %f, z: %f" % (self.x, self.y, self.z)

    def __mul__(self, other):
        return Position(self.x * other, self.y * other, self.z * other)

    def __rmul__(self,other):
        return self.__mul__(other)

    def __add__(self,other):
        return Position(self.x + other.x, self.y + other.y, self.z + other.z)

    def __radd__(self,other):
        return self.__add__(other)
        


def arm(board):
    ''' Arms the drone by sending the arm command to the flight controller'''

    arm_cmd = [1500, 1500, 2000, 900]
    board.sendCMD(8, MultiWii.SET_RAW_RC, arm_cmd)
    rospy.sleep(1)

def disarm(board):
    ''' Disarms the drone by sending the disarm command to the flight
    controller'''
    disarm_cmd = [1500, 1500, 1000, 900]
    board.sendCMD(8, MultiWii.SET_RAW_RC, disarm_cmd)
    rospy.sleep(1)


def heartbeat_callback(msg):
    ''' Updates last_heartbeat to current time upon receipt of heartbeat from
        basestation 
    '''
    global last_heartbeat
    last_heartbeat = rospy.Time.now()


def commanded_mode_callback(msg):
    ''' Updates the commanded mode for the state machine.
        
        This desired mode will be transitioned to by the state machine if it
        is a valid transition
    '''
    global commanded_mode
    commanded_mode = msg.mode


def commanded_position_callback(msg):
    ''' Updates the commanded position '''
    global commanded_position
    commanded_position.x = msg.pose.position.x
    commanded_position.y = msg.pose.position.y
    commanded_position.z = msg.pose.position.z


def current_position_callback_vrpn(msg):
    ''' Updates the drone's current position based on the Motion Tracker '''
    global current_position
    current_position.x = msg.pose.position.x
    current_position.y = msg.pose.position.y
    current_position.z = msg.pose.position.z


def ctrl_c_handler(signal, frame):
    ''' Catches a ctrl-c, and sets the keep_going flag to false'''
    print('Caught ctrl-c! About to Disarm!')
    global keep_going
    keep_going = False


def calc_error(current_position, commanded_position):
    ''' Returns commanded_position - current_position

    current_position and commanded_position are both Position() objects
    that have .x, .y, and .z fields
    '''
    dx = commanded_position.x - current_position.x
    dy = commanded_position.y - current_position.y
    dz = commanded_position.z - current_position.z
    error = Position(dx, dy, dz)
    return error


def clip(num, lower, upper):
    ''' Clips num to be between lower and upper '''
    return max( min(upper, num), lower)


class PositionController(object):
    ''' Runs a low-pass pre-filter on commanded position, then passes off
        control to the position controller based on error between current
        position and filtered-commanded-position
    '''

    def __init__(self):
        self.current_filtered_cmd = Position()
        self.current_cmd = Position()
        self.filtered_cmd_pub = rospy.Publisher('/pidrone/intended_position_filtered', PoseStamped, queue_size=1)
        self.position_pid = PositionPID()


    def step(self, next_commanded_position, current_position):
        ''' Filters next_commanded_position, then passes off to PositionPID. 
            Returns the commands generated by the position pid
        '''

        # The intended position, after filtering
        cmd_pos_filt = self.prefilter_position(next_commanded_position)

        cmd_pos_filt_msg = PoseStamped()
        cmd_pos_filt_msg.pose.position.x = cmd_pos_filt.x
        cmd_pos_filt_msg.pose.position.y = cmd_pos_filt.y
        cmd_pos_filt_msg.pose.position.z = cmd_pos_filt.z
        cmd_pos_filt_msg.header.stamp = rospy.Time.now()

        self.filtered_cmd_pub.publish(cmd_pos_filt_msg)
        
        error = calc_error(current_position, cmd_pos_filt)
        cmds = self.position_pid.step(error)
        return cmds


    def prefilter_position(self, next_commanded_position):
        ''' Runs a low-pass filter on the commanded position '''

        cur_filt_cmd = self.current_filtered_cmd # Filtered position from the previous step
        cur_cmd = self.current_cmd

        c_cur_filt = .999
        c_cmd = .00349

        #c_cur_filt = .999
        #c_cmd = .005

        next_filt = c_cur_filt*cur_filt_cmd + c_cmd*(next_commanded_position + cur_cmd)
        self.current_filtered_cmd = next_filt

        return next_filt

    def reset(self):
        ''' Set current_filtered_cmd to be current position, and reset Position PID'''
        global current_position
        self.current_filtered_cmd = current_position
        self.position_pid.reset()


class PositionPID(object):
    '''THIS NEEDS TO MOVE INTO ANOTHER FILE'''
    def __init__(self):
        self.integrated_error_x = 0
        self.integrated_error_y = 0
        self.integrated_error_z = 0

        self.cur_filt_d_err_y = 0
        self.prev_d_err_y = 0
        self.error_last = None

        self.kd_pub = rospy.Publisher('/pidrone/kd', Float32, queue_size=1)
        self.kp_pub = rospy.Publisher('/pidrone/kp', Float32, queue_size=1)
        self.ki_pub = rospy.Publisher('/pidrone/ki', Float32, queue_size=1)
        self.yerr_pub = rospy.Publisher('/pidrone/yerr', Float32, queue_size=1)

    def step(self, error):
        ''' Give flight controller outputs based on current and previous errors
        '''

        # Negative pitch points nose up
        # Positive pitch points nose down
        # Negative roll rolls left
        # positive roll rolls right

        # with the Motive Tracker setup on 4/25/2018, +Z is toward baxter
        # and +X is left when facing baxter

        # with the drone facing baxter (flight controller pointing toward him),
        # this means +pitch -> +Z, -roll -> +X

        roll_midpoint = 1500
        pitch_midpoint = 1480
        yaw_midpoint = 1500
        thrust_midpoint = 1380


        
        if self.error_last is not None:
            d_err_x = error.x - self.error_last.x
            d_err_y = error.y - self.error_last.y
            d_err_z = error.z - self.error_last.z
        else:
            d_err_x = 0
            d_err_y = 0
            d_err_z = 0


        c_cur_filt = .2
        c_cmd = .6
        cur_filt_d_err_y = c_cur_filt*self.cur_filt_d_err_y + c_cmd*(d_err_y + self.prev_d_err_y)

        self.cur_filt_d_err_y = cur_filt_d_err_y
        self.prev_d_err_y = d_err_y

        d_err_y = cur_filt_d_err_y

        self.error_last = error

        kp_x = .6
        kp_y = 10
        kp_z = .6


        ki_x = 0
        ki_y = .0005
        #ki_y = 0
        ki_z = 0

        kd_x = 2
        kd_y = 180
        kd_z = 2

        # Limit integrated windup to +/- .1, 10% of the thrust
        uc_integrated_error_x = self.integrated_error_x + ki_x*error.x
        self.integrated_error_x = clip(uc_integrated_error_x, -.1, .1)

        uc_integrated_error_y = self.integrated_error_y + ki_y*error.y
        self.integrated_error_y = clip(uc_integrated_error_y, -.1, .1)

        uc_integrated_error_z = self.integrated_error_z + ki_z*error.z
        self.integrated_error_z = clip(uc_integrated_error_z, -.1, .1)


        # negative, because when (cmd - cur) < 0, we want to roll positively
        # roll controls x (for now)
        roll_factor = -(kp_x*error.x + self.integrated_error_x + kd_x*d_err_x)

        # Pitch controls z (for now)
        pitch_factor = kp_z*error.z + ki_z*self.integrated_error_z + kd_z*d_err_z

        # Don't care about yaw (for now)
        yaw_factor = 0

        # Thrust controls height rate
        thrust_factor = kp_y*error.y + self.integrated_error_y + kd_y*d_err_y
        self.yerr_pub.publish(error.y)
        self.kp_pub.publish(kp_y*error.y)
        self.ki_pub.publish(ki_y*self.integrated_error_y)
        self.kd_pub.publish(kd_y*d_err_y)

        cmd_r = roll_midpoint + int(clip(100*roll_factor, -100,100))
        cmd_p = pitch_midpoint + int(clip(100*pitch_factor, -100,100))
        cmd_yaw = yaw_midpoint + int(clip(100*yaw_factor, -100,100))
        cmd_t = int(clip(thrust_midpoint + 100*thrust_factor, 1200,2000))

        return [cmd_r, cmd_p, cmd_yaw, cmd_t]

    def reset(self):
        ''' Set integrated error to 0, and prev error (for D term) to 0 '''
        self.integrated_error_x = 0
        self.integrated_error_y = 0
        self.integrated_error_z = 0
        self.error_last = None


if __name__ == '__main__':

    rospy.init_node('state_controller')

    global last_heartbeat
    last_heartbeat = rospy.Time.now()

    global commanded_mode
    global commanded_position
    commanded_position = Position()

    global current_position 
    current_position = Position()
    global keep_going
    keep_going = True

    # Verbosity between 0 and 3, 3 is most verbose
    verbose = 3

    position_controller = PositionController()

    DISARMED = 0
    ARMED = 1
    FLYING = 2
    END = 9
    current_mode = DISARMED
    commanded_mode = DISARMED

    # This is a sub-state of flying. This is in case you want to have your
    # controller behave differently in different cases (e.g. takeoff vs steady
    # flight, or velocity vs. position hold, or linearized about different
    # orientations. 
    FLYING_MODE = 0


    # ROS Setup
    ###########
    
    # Subscribers
    #############
    rospy.Subscriber('vrpn_client_node/aarondrone/pose', PoseStamped, current_position_callback_vrpn)
    rospy.Subscriber('/pidrone/heartbeat', String, heartbeat_callback)
    rospy.Subscriber('/pidrone/commanded_position', PoseStamped, commanded_position_callback)
    rospy.Subscriber('/pidrone/commanded_mode', Mode, commanded_mode_callback)

    # Publishers
    ############
    error_publisher = rospy.Publisher('/pidrone/err', axes_err, queue_size=1)
    intended_position_publisher = rospy.Publisher('/pidrone/intended_position', PoseStamped, queue_size=1)

    # This should be changed to a message type that is *actually* a Mode type
    current_mode_publisher = rospy.Publisher('/pidrone/current_mode', Mode, queue_size=1)


    # Non-ROS Setup
    ###############
    signal.signal(signal.SIGINT, ctrl_c_handler)
    board = MultiWii('/dev/ttyUSB0')
    analog_data = board.getData(MultiWii.ANALOG)

    loop_rate = rospy.Rate(100)
    print_counter = 0
    try:
        while keep_going:
            print_counter = print_counter + 1
            if ((print_counter % 500) == 0):
                board.getData(MultiWii.ANALOG)
                print('Battery Voltage: %f' % (board.analog['vbat']*.1))


            # Steps the PID. If we are not flying, this can be used to
            # examine the behavior of the PID based on published values
            fly_commands = position_controller.step(commanded_position, current_position)

            if current_mode == DISARMED:
                if commanded_mode == DISARMED:
                    # Self transition, do nothing
                    if verbose > 3:
                        print('DISARMED -> DISARMED')
                elif commanded_mode == ARMED:
                    arm(board)
                    current_mode = ARMED
                    #commanded_position = current_position
                    if verbose >= 3:
                        print('DISARMED -> ARMED')
                elif commanded_mode == END:
                    # Time to end program
                    keep_going = False
                    current_mode = END
                    if verbose >= 3:
                        print('DISARMED -> END')
                else:
                    print('Cannot Transition from Mode %d to Mode %d' % (current_mode, commanded_mode) )
                    
            elif current_mode == ARMED:
                if commanded_mode == ARMED:
                    # Stay in this state, send the idle sequence to prevent
                    # disarming
                    idle_command = [1500, 1500, 1500, 1000]
                    board.sendCMD(8, MultiWii.SET_RAW_RC, idle_command)
                    if verbose > 3:
                        print('ARMED -> ARMED')
                elif commanded_mode == FLYING:
                    current_mode = FLYING
                    pos_index = 0
                    position_controller.reset()
                    if verbose >= 3:
                        print('ARMED -> FLYING')
                elif commanded_mode == DISARMED:
                    disarm(board)
                    current_mode = DISARMED
                    if verbose >= 3:
                        print('FLYING -> DISARMED')
                elif commanded_mode == END:
                    keep_going = False
                    current_mode = END
                    if verbose >= 3:
                        print('FLYING -> END')
                else:
                    print('Cannot Transition from Mode %d to Mode %d' % (current_mode, commanded_mode) )
            elif current_mode == FLYING:
                if commanded_mode == FLYING:
                    print('Updated commanded position to: ')
                    print(commanded_position)
                    # Send command to flight controller based on PID output
                    # at current timestep

                    # Error is a 'position' struct that has .x, .y, and .z fields
                    # giving x, y, and z errors
                    r,p,y,t = fly_commands
                    print('Fly Commands (r,p,y,t): %d, %d, %d, %d' % (r,p,y,t) )
                    board.sendCMD(8,MultiWii.SET_RAW_RC, fly_commands)
                    if verbose > 3:
                        print('FLYING -> FLYING')
                elif commanded_mode == DISARMED:
                    disarm(board)
                    current_mode = DISARMED
                    if verbose >= 3:
                        print('FLYING -> DISARMED')
                elif commanded_mode == END:
                    keep_going = False
                    current_mode = END
                    if verbose >= 3:
                        print('FLYING -> END')
            elif current_mode == END:
                # IT SHOULD *NOT* BE POSSIBLE TO REACH THIS STATE
                keep_going = False
                print('CURRENT MODE = END, but should not get here')

            mode_to_publish = Mode()
            mode_to_publish.mode = current_mode
            current_mode_publisher.publish(mode_to_publish)

            intended_pose = PoseStamped()
            intended_pose.pose.position.y = commanded_position.y
            intended_pose.header.stamp = rospy.Time.now()
            intended_position_publisher.publish(intended_pose)

            loop_rate.sleep()

        # end of main loop
        disarm(board)
    except Exception as ex:
        # This code prints the full exception trace, like errors in the standard
        # python library do. Without this chunk of code, it is very difficult
        # to determine exactly *where* an error occurred. The lack of this code
        # Makes debugging and unknown error very difficult.
        exc_type, exc_value, exc_traceback = sys.exc_info() # most recent (if any) by default


        traceback_details = {
                         'filename': exc_traceback.tb_frame.f_code.co_filename,
                         'lineno'  : exc_traceback.tb_lineno,
                         'name'    : exc_traceback.tb_frame.f_code.co_name,
                         'type'    : exc_type.__name__,
                         'message' : exc_value.message, # or see traceback._some_str()
                        }

        del(exc_type, exc_value, exc_traceback) # So we don't leave our local labels/objects dangling
        # This still isn't "completely safe", though!
        # "Best (recommended) practice: replace all exc_type, exc_value, exc_traceback
        # with sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]

        print
        print traceback.format_exc()
        print
        print traceback_template % traceback_details
        print
        #print(ex)
        disarm(board)
        raise(ex)




